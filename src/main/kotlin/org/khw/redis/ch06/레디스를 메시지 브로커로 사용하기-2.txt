* Stream
    ** 레디스의 Stream과 아파치 카프카
        Stream은 레디스 5.0에서 새로 추가된 자료 구조로 대용량, 대규모의 메시징 데이터를 빠르게 처리할 수 있도록 설계됐다.
        일반적으로 로그가 파일의 내용을 업데이트하거나 지우지 않고 쌓기만 하는 것처럼 stream 또한 데이터를 계속해서 추가하는 방식으로 저장되는 자료 구조다.

        stream은 사용 목적에 따라 크게 두 가지 방식으로 활용될 수 있다. 첫 번째로, 백엔드 개발자들은 stream을 대량의 데이터를 효율적으로 처리하는
        플랫폼으로 활용할 수 있다. 두 번째로, 데이터 엔지니어들은 stream을 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터
        저장소 및 중간 큐잉 시스템으로 사용할 수 있다.

        대규모 메시징 데이터를 처리하기 위해 플랫폼을 도입하고자 할 때 가장 먼저 고려되는 시스템은 아파치 카프카일 것이다. 카프카는 링크드인에서 처음 개발된
        분산 메시징 시스템이며 2011년에 오픈 소스로 공개된 뒤 현재는 Confluent에서 관리하고 있다.

        레디스 stream은 카프카의 영향을 많이 받은 시스템인 만큼 카프카와 유사한 여러 기능을 갖고 있으며, 일부 기능은 카프카보다 뛰어난 처리를 할 수 있도록 설계됐다.

    ** 스트림이란?
        컴퓨터 과학에서 스트림이란 연속적인 데이터의 흐름, 일정한 데이터 조각의 연속을 의미한다.
        끝이 정해지지 않고 계속되는 불규칙한 데이터를 연속으로 반복 처리할 때 이 또한 스트림 처리를 한다고 부를 수 있다.

    ** 데이터의 저장 - 메시지의 저장과 식별
        카프카에서 스트림데이터는 토픽이라는 개념에 저장된다. 토픽은 각각의 분리된 스트림을 뜻하며, 같은 데이터를 관리하는 하나의 그룹을 의미한다.

        레디스에서는 하나의 stream 자료 구조가 하나의 stream을 의미한다. 레디스의 string, hash, sorted set 등 다른 자료 구조와 마찬가지로 stream
        형태의 자료 구조가 존재하며, 각 자료 구조와 마찬가지로 stream 형태의 자료 구조가 존재하며, 각 자료 구조가 하나의 키에 연결되는 것과 마찬가지로
        stream 또한 하나의 키에 연결된 자료 구조다.

        카프카에서 각 메시지는 0부터 시작해 증가하는 시퀀스 넘버로 식별할 수 있는데, 이때 시퀀스 넘버는 토픽 내의 파티션 안에서만 유니크하게 증가하기 때문에 토픽이
        1개 이상의 파티션을 갖는다면 메시지는 하나의 토픽 내에서 유니크하게 식별되지 않는다.

        레디스 stream에서 각 메시지는 시간과 관련된 유니크한 ID를 가지며, 이 값은 중복되지 않는다. ID는 다음과 같이 2개의 파트로 나눈다.
        <millisecondsTime>-<sequenceNumber>

        밀리세컨드 파트는 실제 stream에 아이템이 저장될 시점의 레디스 노드 로컬 시간이다. 시퀀스 파트는 동일한 밀리세컨드 시간에 여러 아이템이 저장될 수 있으므로,
        같은 밀리세컨드에 저장된 데이터의 순서를 의미한다. 시퀀스 번호는 64bit로, 사실상 하나의 밀리세컨드내에 생성할 수 있는 항목 수에는 제한이 없는 것과 같다

        레디스 stream에 저장된 모든 데이터는 유니크한 ID를 가지며, 이 ID 값이 곧 시간을 의미하기 때문에 시간을 이용해 특정 데이터를 검색할 수 있다.

        레디스에서는 따로 stream을 생성하는 과정은 필요하지 않으며, XADD 커맨드를 이용해 새로운 이름의 stream에 데이터를 저장하면 데이터의 저장과 동시에 stream
        자료 구조가 생성된다.


        > XADD Eamil * subject "first" body "hello?"
        "1711777290766-0"

        // XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
        > XREAD BLOCK 0 STREAMS Eamil 0
        1) 1) "Eamil"
           2) 1) 1) "1711777290766-0"
                 2) 1) "subject"
                    2) "first"
                    3) "body"
                    4) "hello?"

        BLOCK 0은 더 이상 stream에서 가져올 데이터가 없더라도 연결을 끊지 말고 계속 stream을 리스닝하라는 의미이다.
        만약 BLOCK 1000을 입력했다면 들어오는 데이터가 없더라도 1000ms 즉 최대 1초 동안 연결을 유지하며 대기하라는 것을 의미한다.

        STREAMS Email 0 이라는 커맨드는 Email이라는 stream에 저장된 데이터 중 ID가 0보다 큰 값을 읽어오라는 의미이며
        즉 stream에 처음부터 저장된 모든 데이터를 읽어오라는 것을 의미한다.

        커맨드를 실행한 이후의 메시지만을 가져오고 싶다면 0 대신 특수 ID인 $를 입력하면 된다. 이 특수 ID를 전달하면 커맨드를 실행한 이후의
        데이터부터 가져온다.
        즉 $는 stream에 저장된 최대 ID를 의미하는 것이라 생각할 수 있다.

        혹은 다음과 같이 직접 ID 값을 지정해서 데이터를 읽을 수 있다
        > XREAD BLOCK 0 STREAMS Eamil 0 1659115180983

    ** 특정한 데이터 조회
        XRANGE key start end [COUNT count]
        XREVRANGE key start end [COUNT count]

        XRANGE 커맨드를 이용하면 ID를 이용 원하는 시간대의 데이터를 조회할 수 있다.
        stream에 저장된 ID 중 가장 작은 ID 값을 지정하고 싶을 때에는 -, 제일 마지막 ID 값을 지정하고 싶을 때에는 + 기호를 사용하자.
        XREVRANGE는 XRANGE의 역순으로 데이터를 조회하고 싶을 때 사용한다.


        > XRANGE Eamil - +
        1) 1) "1711777290766-0"
           2) 1) "subject"
              2) "first"
              3) "body"
              4) "hello?"

        이 커맨드는 앞서 XREAD BLOCK 0 STREAMS Eamil 0 커맨드를 수행했을 때의 결과와 같다고 생각할 수 있다.
        하지만 XREAD 사용했을 때에는 기존 데이터를 모두 반환한 뒤, 신규로 들어오는 메시지를 계속해서 반환하지만, XRANGE 커맨드는
        커맨드를 수행하는 시점에 stream에 저장된 모든 데이터를 반환한 뒤 종료된다는 차이점이 존재한다.

        XRANGE를 이용한다면 메시지가 저장된 시점을 이용해 데이터를 조회할 수도 있다.

        > XRANGE Email 1659114481310 1659114481319
        1) 1) "1659114481311-0"
           2) 1) "subject"
              2) "first"
              3) "body"
              4) "hello?"

        타임 스탬프 값에 ( 문자를 포함하면 그 다음 데이터부터 조회한다

        XRANGE Email 1659114481311-0 + // 1659114481311-0 key 부터 ~
        XRANGE Email ( 1659114481311-0 + // 1659114481311-0 key 다음 부터 ~

