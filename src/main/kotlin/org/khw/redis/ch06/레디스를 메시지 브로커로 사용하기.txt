* 메시징 큐와 이벤트 스트림
    메시징 큐에서
        데이터를 생성하는 쪽을 생산자(Producer)
        데이터를 수신하는 쪽을 소비자(Consumer)

    이벤트 스트림에서
        데이터를 생성하는 쪽을 발행자(Publisher)
        데이터를 수신하는 쪽을 구독자(Subscriber)

    ** 차이점
        1) 방향성
            메시징 큐의 생산자는 소비자의 큐로 데이터를 직접 푸시한다.
            2개의 서비스에 같은 메시지를 보내야 할 때 메시징 큐를 이용한다면 생산자는 2개의 각각 다른 메시징 큐에 각각 데이터를 푸시해야 한다
            반면 이벤트 스트림을 이용한다면 생산자는 스트림의 특정 저장소에 하나의 메시지를 보낼 수 있고, 메시지를 읽어가고자 하는 소비자들은
            스트림에서 같은 메시지를 pull 해 갈 수 있기 때문에 메시지를 복제해서 저장하지 않아도 된다.
        2) 데이터의 영속성
            메시징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제한다. 하지만 이벤트 스트림에서 구독자가 읽어간 데이터는 바로 삭제되지 않고
            저장소의 설정에 따라 특정 기간 동안 저장될 수 있다.

            메시지를 보내는 도중에 새로운 소비자를 추가할 때, 메시징 큐를 이용한다면 소비자는 새롭게 추가된 이후의 이벤트만 확인할 수 있다.
            하지만 스트림 방식에서는 메시지를 생산할 때 구독자를 저장하지 않고, 스트림에 쌓인 데이터는 일정 기간동안 지워지지 않기 때문에
            새로 추가된 서비스도 스트림에 남아 있는 이전 데이터희 히스토리를 볼 수 있다.

            따라서 메시징 큐는 일대일 상황에서 한 서비스가 다른 서비스에게 동작을 지시할 때 유용하게 사용될 수 있으며, 스트림은 다대다
            상황에서 유리함을 확인할 수 있다.

* 레디스를 메시지 브로커로 사용하기
    레디스에서 제공하는 pub/sub를 사용하면 빠르고 간단한 방식으로 메시지를 전달할 수 있는 메시지 브로커를 구현할 수 있다.
    발행자가 특정한 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자는 데이터를 바로 소비할 수 있다.
    레디스의 pub/sub에서 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가지며, 메시지가 잘 전달됐는지 등의 정보는
    보장하지 않는다. 따라서 완벽하게 메시지가 전달돼야 하는 상황에는 적합하지 않을 수 있지만 fire-and-forget 패턴이 필요한 간단한 알림
    서비스에서는 유용하게 사용될 수 있다

        ** fire-and-forget 패턴은 비동기 프로그래밍에서 사용되는 디자인 패턴으로, 어떤 작업을 실행하고 그 결과에 대한 응답을 기다리지 않고
        바로 다음 코드를 실해하는 것을 의미한다. 이 패턴은 주로 성능 향상이나 비동기 작업을 수행할 때 사용되며, 작업의 완료나 결과에 대한 처리가 필요하지
        않을 때 유용하게 사용된다. 예를 들어 로깅, 이벤트 발행, 통계 데이터 수집과 같이 작업의 성공 또는 실패에 대한 관심이 없는 경우에 활용될 수 있다
        결과 확인이나 오류 처리를 고려하지 않고 작업을 진행하므로 신뢰성이 필요한 경우에는 사용하지 않아야 한다.

    레디스의 list 자료 구조는 메시징 큐로 사용하기에 알맞다. list의 데이터는 푸시와 팝이 가능하며 list에 데이터가 있는지 매번 확인할 필요 없이 대기하다가
    list에 새로운 데이터가 들어오면 읽어갈 수 있는 블로킹 기능을 사용할 수도 있다.

    레디스의 stream을 사용하면 레디스를 완벽한 스트림 플랫폼으로 사용할 수 있다. 레디스 stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료 구조로, 데이터는 계속해서
    추가되는 방식으로 저장된다. 소비자와 소비자 그룹이 stream에 저장되는 메시지를 실시간으로 리스닝하며 소비할 수도 있으며, 저장돼 있는 데이터를
    시간대별로 검색하는 것도 가능

* 레디스의 pub/sub
    레디스는 아주 가벼운 pub/sub 기능을 제공한다. 레디스 노드에 접근할 수 있는 모든 클라이언트는 발행자와 구독자가 될 수 있다. 발행자는 특정 채널에 메시지를
    보낼 수 있으며, 구독자는 특정 채널을 리스닝하다가 메시지를 읽어갈 수 있다.

    레디스에서 pub/sub/는 매우 가볍기 때문에 최소한의 메시지 전달 기능만 제공한다.
    발행자는 메시지를 채널도 보낼 수 있을 뿐, 어떤 구독자가 메시지를 읽어가는지, 정상적으로 모든 구독자에게 메시지가 전달됐는지
    확인할 수 없다. 그독자 또한 메시지를 받을 수 있지만 해당 메시지가 언제 어떤 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없다.

    한 번 전파된 데이터는 레디스에 저장되지 않으며, 단순히 메시지의 통로 역할만 한다. 만약 특정 구독자에 장애가 생겨 메시지를 받지 못했다 하더라도
    그 사실을 알 수 없기 때문에 정합성이 중요한 데이터를 전달하기에는 적합하지 않을 수 있다. 이럴 경우 애플리케이션 레벨에서 메시지의 송수신과 관련한 로직을 추가해야 할 수 있다.


    > PUBLISH hello world
    (integer) 1 // 메시지를 수신한 구독자의 수 반환

    > SUBSCRIBE hello // hello라는 채널을 구독
    Reading messages... (press Ctrl-C to quit)
    1) "subscribe"
    2) "hello"
    3) (integer) 1

    클라이언트가 구독자로 동작할 때에는 새로운 채널을 구독할 수 있지만 pub/sub과 관련되지 않은 다른 커맨드를 수행할 수는 없다
    구독자가 수행할 수 있는 커맨드는 SUBSCRIBE, SSUBSCRIBE, SUNSUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE,
    PING, RESET, QUIT

    PSUBSCRIBE 커맨드를 사용하면 일치하는 패턴에 해당하는 채널을 한 번에 구독할 수 있으며, 이때 레디스는 glob-style 패턴을 지원한다.

    > PSUBSCRIBE mail-*
    Reading messages... (press Ctrl-C to quit)
    1) "psubscribe"
    2) "mail-*"
    3) (integer) 1

    SUBSCRIBE와 마찬가지로 동시에 여러 문자열을 구독하는 것도 가능하다. 이때 메시지는 message가 아닌 pmessage 타입으로 전달되며,
    SUBSCRIBE 커맨드를 이용해 메시지를 구독하는 방식과 구분된다.

*클러스터 구조에서의 pub/sub
    레디스 클러스터 구조에서도 pub/sub을 사용할 수 있다. 클러스터는 레디스가 자체적으로 제공하는 데이터 분산 형태의 구조다.

    레디스 클러스터에서 pub/sub을 사용할 때,, 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달된다.
    따라서 레디스 클러스터의 아무 노드에 연결해 SUBSCRIBE 커맨드를 사용하면 데이터를 수신할 수 있다.

    하나의 노드에 메시지를 발행하면 메시지는 모든 노드에 전파된다. 이 방법은 간단하고 명료하지만, 사실 클러스터의 주요 목적을 고려한다면
    비효율적인 방식으로 여겨질 수 있다. 클러스터는 주로 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입됐으며, 그렇기 때문에
    레디스 클러스터 내에서 pub/sub을 사용할 때 메시지가 모든 레디스 노드에 복제되는 방식은 클러스터 환경의 핵심 목표와는 부합하지 않으며,
    이로 인해 불필요한 리소스 사용과 네트워크 부하가 발생할 수 있다.

    ** shareded pub/sub
        위의 비효율을 해결하기 위해 레디스 7.0에서는 shareded pub/sub 기능이 도입됐다. sharded pub/sub 환경에서 각 채널은 슬롯에
        매팽된다. 클러스터에서 키가 슬롯에 할당되는 것과 동일한 방식으로 채널이 할당되며, 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파한다.

        ** 슬롯
            레디스 클러스터에서 "슬롯"은 전체 데이터를 16384개의 부분으로 나누어 여러 서버 노드에 분산 저장하는 방식입니다. 각 키는 특정 슬롯에 할당되며,
            이를 통해 데이터를 관리하고 요청을 처리합니다. 슬롯 시스템을 사용함으로써 레디스 클러스터는 데이터를 효율적으로 분산시키고, 성능 및 확장성을 개선할 수 있습니다.

    SPUBLISH 커맨드는 발행된 메시지는 모든 노드에 전파되지 않으며, 노드의 복제본에만 전달된다
    > SPUBLISH apple a
    -> Redirected to slot [7902] located at 10.0.0.2:6379
    (integer) 1

    Sharded pub/sub을 이용한다면 클러스터 구조에서 pub/sub되는 메시지는 모든 노드로 전파되지 않기 때문에 불필요한 복제를 줄여 자원을 절야할 수 있다는 강점이 있다.

* 레디시의 list를 메시징 큐로 사용하기
    레디스의 자료 구조 중 하나인 list는 큐로 사용하기 적절한 자료 구조다. 레디스에는
    큐의 tail과 head에서 데이터를 넣고 뺄 수 있는 LPUSH, LPOP, RPUSH, RPOP 커맨드가 존재하기 때문에 애플리케이션 특성에 맞는 메시징 큐를 직접 구현할 수 있다는 장점이 있다.

    ** list의 EX 기능
        인스타그램, 트위터, 페이스북, 유튜브와 같은 SNS에는 각 유저별 타임라인이 존재하며 각자의 타임라인에 자신이 팔로우한 계정의 게시물, 혹은 자신과 관련 있는 게시물
        등이 표시되다. 모든 유저는 제각기 다른 타임라인을 가짐을 뜻한다.

        트위터는 각 유저의 타임라인 캐시 데이터를 list 자료 구조로 관리한다.

        유저 A가 새로운 트윗을 작성하면 그 데이터는 A를 팔로우하는 유저의 타임라인 캐시에 저장된다 A가 쓴 트윗의 데이터는 유저 B와 C의 타임라인 캐시 list에 새로운
        아이템으로 추가된다.

        이때 각 타임라인 캐시에 데이터를 저장할 때 RPUSH 커맨드가 아닌 RPUSHX 커맨드를 사용함을 주목해보자. RPUSHX는 데이터를 저장하고자 하는 list가 이미 존재할때에만
        아이템을 추가하는 커맨드다. 이 커맨드를 이용하면 이미 캐시된(이미 키가 존재하는) 타임라인에만 데이터를 추가할 수 있다. 자주 트위터를 들어오지 않는 D 유저에 대해서는
        타임라인 캐시 데이터를 굳이 관리해야 할 필요가 없기 때문이다.

        RPUSHX를 사용한다면 사용자의 캐시가 이미 존재하는지의 유무를 애플리케이션에서 확인하는 과정 없이,
        모든 로직을 레디스에서 제어할 수 있기 때문에 불필요한 확인 과정을 줄여 성능을 향상시킬 수 있게 된다.

        > RPUSHX Timelinecache:userB data3
        (integer) 0
        > RPUSH Timelinecache:userB data3
        (integer) 1
        > RPUSH Timelinecache:userC data3
        (integer) 1
        > RPUSH Timelinecache:userD data3
        (integer) 1
        > RPUSHX Timelinecache:userB data4
        (integer) 2
        > RPUSHX Timelinecache:userB data4
        (integer) 3


    **list의 블로킹 기능
        레디스를 이벤트 큐로 사용할 경우 블로킹 기능 또한 유용하게 사용할 수 있다.
        이벤트기반 구조에서 시스템은 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 체크한다

        이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 체크하며, 새로운 이벤트가 업슬 경우 정해진 시간(풀링 인터벌) 동안 대기한 뒤 다시 이벤트 큐에
        데이터가 있는지 확인하는 과정을 반복한다. 이러한 작업을 폴링이라고 하며, 폴링 프로세스가 진행되는 동안 애플리케이션과 큐의 리소스가 불필요하게
        소모될 수 있다. 또한 이벤트 큐에 이벤트가 들어왔을 수 있지만, 폴링 인터벌 시간동안은 대기한 뒤 다시 확인하는 과정을 거치기 때문에
        이벤트를 즉시 처리할 수 없다는 단점이 있다.

        이때 list의 블로킹 기능을 사용하면 이와 같은 불필요함을 줄일 수 있다. BRPOP과 BLPOP은 각각 RPOP과 LPOP에 블로킹을 추가한 커맨드다.
        클라이언트가 BLPOP을 사용하해 데이터를 요청했을 때 list에 데이터가 있으면 즉시 반환한다. 만약 데이터가 업슬 경우에는
        list에 데이터가 들어올 때까지 기다린 후에 들어온 값을 반환하거나, 클라이언트가 설정한 타임아웃시간만큼 대기한 후에 nil 값을 반환한다.

        > BRPOP queue:a 5
        1) "queue:a"
        2) "data"

        queue:a에 데이터가 입력될 때까지 최대 5초 동안 대기하고, 5초가 경과하면 nil을 반환하라는 의미다.
        타임아웃 값을 0으로 설정하면 데이터가 리스트에 들어올 때까지 제한 없이 기다리라는 의미로 쓰인다. 하나의 리스트에 대해 여러 클라이언트가 동시에
        블로킹될 수 있으며 리스트에 데이터가 입력되면 가장 먼저 요청을 보낸 클라이언트가 데이터를 가져간다.

        BRPOP은 RPOP과는 다르게 2개의 데이터를 반환한다. 첫 번째는 팝된 리스트의 키 값을 반환하고, 두 번째에 반환된 데이터의 값을 반환한다.
        이렇게 설계된 이유는 동시에 여러 개의 리스트에서 대기할 수 있게 하기 위해서다.

        > BRPOP queue:a queue:b queue:c timeout 1000 // 1,000초 동안 queue:a, queue:b, queue:c 구독
        1) queue:b
        2) "DATA"
        (19.89s)

    * list를 이용한 원형 큐
        만약 특정 아이템을 계속해서 반복 접근해야 하는 클라이언트, 혹은 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 클라이언트에서는
        원형 큐를 이용해 아이템을 처리하고 싶을 수 있다.

        > LPUSH clist A
        (integer) 1
        > LPUSH clist B
        (integer) 2
        > LPUSH clist C
        (integer) 3
        > LRANGE clist 0 -1
        1) "C"
        2) "B"
        3) "A"
        > RPOPLPUSH clist clist
        "A"
        > LRANGE clist 0 -1
        1) "A"
        2) "C"
        3) "B"
