* 캐시에서의 데이터 흐름
    기본적으로 캐시는 데이터 스토어가 갖고 있는 데이터 중 사용자가 자주 사용할 만한 데이터를 갖고와서 임시로 저장하는 저장소다.
    따라서 데이터 스토어보다 적은 양을 보관하는 데이터베이스의 서브셋이라고 볼 수 있다. 레디스는 특히 메모리에 모든 데이터를 저장하며,
    기본적으로 메모리는 서버의 스토리지보다 훨씬 적은 양을 보관할 수밖에 없다.
    따라서 캐시는 가득 차지 않게 일정 양의 데이터를 유지해야 하며 계속해서 새로운 데이터가 저장되고 기존 데이터는 삭제될 수 있도록 관리돼야 한다.
    따라서 캐시로 레디스를 사용할 때에는 데이터를 저장함과 동시에 적절한 시간의 TTL 값을 지정하는 것이 좋다.

* 만료시간
    레디스에서 만료 시간, 즉 TTL은 데이터가 얼마나 오래 저장될 것인지를 나타내는 시간 설정이다. 레디스는 데이터베이스 내의 특정 키에 대한 만료 시간을
    설정 할 수 있으며, 이는 데이터의 유효 기간 또는 만료 시간을 정의하는 데 사용된다.

    만료 시간은 일반적으로 초 단위로 표현되며, 특정 키에 대한 만료 시간이 설정 되면 해당 키와 관련된 데이터는 지정된 시간이 지난 후에 레디스에서
    자동으로 삭제된다. 이를 통해 레디스에서 임시 데이터를 처리하거나 캐시 데이터를 유지하고 관리 할 수 있다. 키에 만료시간을 설정하면
    데이터의 수명을 관리하고 메모리 공간을 효율적으로 사용하는 데 도움을 준다.

    레디스에 저장된 키에 EXPIRE 커맨드를 사용하면 만료 시간을 설정할 수 있다. SET 커맨드로 string 데이터를 저장할 때에는 EX 옵션을 함께 사용해
    데이터의 저장과 동시에 만료 간을 술정할 수도 있다. TTL 커맨드를 사용하면 키에 대한 만료 시간을 확인할 수 있는데, 만료 시간이 남아 있다면
    남은 시간을 반환하며, 키가 존재하지 않을 때에는 -2를, 키에 대해 만료 시간이 지정되지 않았을 경우에는 -1을 반환한다.
    TTL와 EXPIRE 커맨드는 초 단위로 동작하며, PTTL과 PEXPIRE 커맨드는 밀리세컨드 단위로 동작

    > SET a 100
    OK
    > EXPIRE a 60
    (integer) 1
    > TTL a
    (integer) 56
    > TTL a
    (integer) 54

    설정된 만료시간은 INCR 커맨드로 데이터를 조작하거나 RENAME을 이용해 키의 이름을 바꾸더라도 설정된 만료 시간은 변경되지 않는다.

    > SET b 200
    OK
    > EXPIRE b 69
    (integer) 1
    > TTL b
    (integer) 65
    > SET b banana
    OK
    > TTL b
    (integer) -1

    그러나 기존 키에 새로운 값을 저장해 키를 덮어 쓸 때에는 이전에 설정한 만료 시간은 유지되지 않고 사라진다.

    ** 레디스에서 키가 만료됐다고 해도 바로 메모리에서 삭제되는 것은 아니다. 키는 passive 방식과 active방식 이 두 가지로 삭제된다.
    - passive 방식 : 클라이언트가 키에 접근하고자 할 때 키가 만료됐다면 메모리에서 수동적으로 삭제한다. 사용자가 접근할 때에만
    수동적으로 삭제되기 때문에 이를 passive 방식의 만료라 한다. 그러나 사용자가 다시 접근하지 않는 만료된 키도 있어 이 방식만으로는 충분하지 않다.

    - active 방식 : TTL 값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤, 만료된 키를 모두 메모리에서 삭제한다.
    만약 25% 이상의 키가 삭제됐다면 다시 20개의 키를 랜덤하게 뽑은 뒤 확인하고, 아니라면 뽑아놓은 20개의 키 집합에서 다시 확인한다.
    이러한 과정을 1초에 10번씩 수행한다

* 메모리 관리와 maxmemory-policy 설정
    레디스에서 키에 만료 시간을 설정해 데이터가 자동으로 삭제되도록 함으로써 데이터의 수명을 관리할 수 있다. 하지만 레디스의 메모리는 제한적이기 때문에
    모든 키에 만료 시간을 설정하더라도 너무 많은 키가 저장되면 메모리가 가득 차는 상황이 발생 할 수 있다. 메모리 용량을 초과하는 양의 데이터가
    저장되면 레디스는 내부 정책을 사용해 어떤 키를 삭제할지 결정한다.

    레디스에서는 데이터의 최대 저장 용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리 방식을 결정하는 maxmemory-policy 설정값을
    사용해 메모리를 관리한다.

    ** Noeviction
        기본값은 noeviction, 이 값은 레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는
        에러를 반환하는 설정값

    ** LRU eviction(근사치 알고리즘)
        LRU eviction이란 레디스에 데이터가 가득 찼을 때 가장 최근에 사용되지 않는 데이터부터 삭제하는 정책

        - volatile-lru : 만료 시간이 설정돼 이쓴 키에 한해서 LRU 방식으로 키를 삭제한다.
            만약 레디스에 저장된 모든 키에 만료시간이 지정돼 있지 않다면 Noeviction과 동일하다

        - allkeys-LRU : 레디스 공식문서에서 추천하는 방식
            모든 키에 대해 LRU 알고리즘을 이용해 데이터를 삭제

    ** LFU eviction(근사치 알고리즘)
        LFU eviction이란 레디스에 데이터가 가득 찼을 때 가장 자주 사용되지 않은 데이터부터 삭제하는 정책.
        LFU는 LRU와 유사하지만 키를 액세스하는 패턴에 따라 우선순위가 유동적으로 바뀐다는 점에서 특정 케이스에서 LRU보다 더 효율적일 수 있다

        - volatile-lfu : 만료 시간이 설정돼 있는 키에 한해서 LFU 방식으로 키를 삭제한다.
            volatile-lru에서와 마찬가지로 특정 상황에서는 장애를 유발할 가능성이 존재

        - allkeys-lfu : 모든 키에 대해 LFU 알고리즘을 이용해 데이터를 삭제

    ** RANDOM eviction
        이 옵션은 레디스에 저장된 키 중 하나를 임의로 골라내 삭제
        LRU, LFU 알고리즘을 사용하지 않기 때문에 삭제될 키 값의 근사치를 계산하지 않아도 된다는 점에서
        레디스의 부하를 줄여줄 수 있다 다만 나중에 사용될 데이터를 삭제할수 있다는 점에서 권장하지 않는 방법

        - volatile-random : 만료시간이 설정돼 있는 키에 한해서 랜덤하게 키를 삭제
        - allkeys-random : 모든 키에 대해 랜덤하게 키를 삭제

    ** volatile-ttl
        만료시간이 가장 작은 키를 삭제 근사 알고리즘 사용

* 캐시 스탬피드 현상
    레디스를 캐시로 활용할 때 모든 키에 대해 만료 시간을 설정하는 것은 권장되지만,
    대규모 트래픽 환경에서 만료시간을 어떻게 설정하느냐에 따라 캐시 스탬피드와 같은 문제상황 발생 가능

    look aside 방식에서 애플리케이션은 레디스에 먼저 데이터가 있는지 질의한 후 데이터가 없을 때 데이터베이스에서
    데이터를 읽어오는 과정을 반복한다.

    만약 여러개의 애플리케이션에서 바라보던 키가 레디스에서 만료돼 삭제된다면 이 서버들은 한꺼번에 데이터베이스에 가서 데이터를 읽어오는 과정을 거친다.
    이를 중복읽기라 하며, 이후 각 애플리케이션에서 읽어온 데이터를 레디스에 쓰게 되는데, 이 또한 여러번 반복되기 때문에 중복 쓰기가 발생한다.

    일반적으로 정렬이나 카운팅처럼 데이터베이스에서 쿼리하는데 오랜 시간이 걸리는 작업을 미리 계산해서 캐시에 저장해두기 때문에, 캐시에 데이터가 없는 경우
    이 데이터를 다시 데이터베이스에 접근해서 계산하는 작업이 필요하다. 레디스에 데이터가 없다는 것을 인지한 여러 애플리케이션에서
    동시에 데이터베이스에 접근해 무거운 쿼리를 실행하는 중복 읽기 작업은 데이터 베이스에 부하를 줄 수 있으며, 이는 곧 서비스 이슈로도 이루어 질수 있다

    ** 적절한 만료시간 설정
        캐시 스탬피드를 줄이기 위한 가장 간단한 방법은 만료시간을 너무 짧지 않게 설정하는 것이다.
        여러 애플리케이션에서 한꺼번에 접근해야 하는 데이터이며, 반복적으로 사용돼야 하는 데이터라면 저장 시점부터 만료 시간을 충분히 길게 설정하는 것이 좋다.

    ** 선 계산
        look aside 방식으로 캐시를 사용할 때 애플리케이션은 다음 코드와 비슷하게 동작 할 것이다.
        캐시에 데이터가 있는지 확인한 뒤 없으면 데이터베이스에서 데이터를 가져온 뒤 다시 레디스에 저장하는 과정을 거친다

        캐시 스탬피드가 문제되는 이유는 데이터가 만료되는 시점에 여러 애플리케이션에서 동시다발적으로 이를 인지하고 이후 작업을 동시에 진행하기 때문
        만약 키가 실제로 만료되기 전에 이 값을 미리 갱신해준다면 여러 애플리케이션에서 한꺼번에 데이터베이스에 접근해 데이터를 읽어오는 과정을 줄여 불필요한 프로세스를 줄일 수 있다

        // 랜덤한 확률로 db에 접근해 데이터를 가져오 키 갱신
        def fetch(key, expiry_gap):
            ttl = redis.ttl(key)

            if ttl - (random() * expiry_gap) > 0:
                return redis.get(key)

            else:
                value = db.fetch(key)
                redis.set(value, KEY_TTL)
                return value


        fetch('hello', 2)