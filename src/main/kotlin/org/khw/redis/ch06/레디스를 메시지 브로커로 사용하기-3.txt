* Stream의 컨슈머 그룹
    팬아웃(같은 데이터를 여러 소비자에게 전달하는 것)
    레디스 stream에서는 데이터가 저장될 때마다 고유한 ID를 부여받아 순서대로 저장된다. 따라서 소비자에게 데이터가 전달될 때, 그 순서는 항상 보장된다.

    반면 카프카에서 유니크 키는 파티션 내에서만 보장되기 때문에 소비자가 여러 파티션에서 토픽을 읽어갈 때에는 데이터의 순서를 보장할 수 없다.

    메시지는 토픽에 저장될 때 해시함수에 의해 N개의 파티션에 랜덤하게 분배되며, 소비자가 토픽에서 데이터를 소비할 때에는 파티션의 존재를 알지 못하고, 토픽
    내의 전체 파티션에서 데이터를 읽어온다. 이때 여러 파티션 간 데이터의 정렬은 보장되지 않기 때문에 결국 소비자가 데이터를 읽어올 때에는 정렬이
    보장되지 않는 데이터를 읽어오게 된다. 따라서 카프카에서 메시지 순서가 보장되도록 데이터를 처리하기 위해서는 소비자 그룹을 사용해야 한다.

    ** 소비자 그룹
    카프카에서는 소비자 그룹에 여러 소비자를 추가할 수 있으며, 이때 소비자는 토픽 내의 파티션과 일대일로 연결된다.

    레디스 stream에서도 소비자 그룹이라는 개념이 존재하지만, 카프카에서와는 다른 레디스 stream은 카프카와는 달리
    메시지가 전달되는 순서를 신경 쓰지 않아도 되기 때문이다. 레디스 stream에서 소비자 그룹 내의 한 소비자는 다른 소비자가 아직
    읽지 않은 데이터만을 읽어간다.

    ** 소비자 그룹 생성
    > XGROUP CREATE Email EmailServiceGroup $

    이 커맨드를 이용하면 Email stream을 읽어가는 EmailServiceGroup이라는 소비자 그룹을 생성할 수 있으며, $는 현재 시점 이후의 데이터부터
    리스닝하겠다는 것을 의미한다.

    소비자 그룹을 이용해 데이터를 읽어오고 싶다면 XREADGROUP 커맨드를 사용하면 된다. XREADGROUP은 XREAD와 같은 형태로 데이터를 응답하지만
    지정한 소비자 그룹을 통해서 데이터를 읽길 원한다는 것을 뜻한다.
    > XREADGROUP GROUP EmailServiceGroup emailService1 COUNT 1 STREAMS Email >
    EmailServiceGroup에 속한 emailService1이라는 이름의 소비자가 Email stream에 있는 1개의 메시지를 읽어오고자 하는 커맨드다.
    매번 소비자가 소비자 그룹을 이용해 작업을 수행할 때마다 그룹 내에서 이 소비자를 고유하게 식별할 수 있는 이름을 지정해야 한다.

    만약 다른 소비자에게 읽히지 않은 데이터가 있다면 데이터를 1개 가져오고, 없다면 nil 값을 반환한다. 카프카와는 다르게 레디스 stream에서 각 소비자는
    COUNT 커맨드를 이용해 소비할 메시지 개수를 직접 지정할 수 있다.

    STREAM Email > 이 의미하는 것은 Email이라는 이름의 stream에서, 다른 소지바에게 전달되지 않았던 새로운 메시지를 전달하라는 것을 의미한다.
    소비자 그룹을 사용하는 이유가 다른 소비자에게 전달되지 않았던 데이터를 가지고 오는 것이기 때문에, 대부분의 상황에서 >를 사용하면 되겠지만 만약 0
    또는 다른 숫자 ID를 입력할 경우 새로운 메시지를 확인하는 것이 아닌, 입력한 ID보다 큰 ID 중 대기 list(pending list)에 속한 메시지를 반환한다.

    소비자는 처음 언급될 때 자동으로 생성되며 명시적으로 생성할 필요는 없다. XREAD GROUP을 사용하면 여러 stream 데이터를 동시에 읽어올 수 있지만
    이를 가능하게 하기 위해서는 stream에 동일한 이름을 가진 소비자 그룹을 먼저 생성해야 한다.

    XREADGROUP을 사용해 stream 데이터를 읽어올 때, 읽어오는 동작 자체가 소비자 그룹에 영향을 미치기 때문에 일종의 쓰기 커맨드로 생각해야 한다.
    그렇기 때문에 이 커맨드는 마스터에서만 호출할 수 있다.

    레디스 stream에서 소비자 그룹은 stream의 상태를 나타내는 개념으로 간주된다.
    이렇게 생각하면 보류된 메시지의 관리 방식과, 새로운 메시지를 요청하는 소비자가 매번 새로운 메시지의 ID를 할당받을 수 있는 방법을 이해하기 쉬워질것이다.
    게다가 하나의 stream이 여러개의 소비자 그룹을 가질 수 있다는 사실 또한 명확하게 이해할 수 있을 것이다.

    ** 소비자 그룹은 stream의 상태를 나타내는 개념
        Stream: Email
        소비자 그룹 : EmailServiceGroup
        last_deliverd_id : 1659115180984-0

        소비자
            - 이메일 서버 1 에서 pending 된 메시지 리스트
                - 1659115180752-0
                - 1659115180984-0

            - 이메일 서버 2 에서 pending 된 메시지 리스트
                - 1659115180984-0

    부하 분산의 관점에서 카프카와 비교해서 생각해보자. 카프카가 파티션이라는 개념을 이용해 소비자의 부하 분산을 관리한다면 레디스의 stream은 파티션이라는
    분할 없이도 소비자 그룹이라는 개념을 이용해 여러 소비자에게 stream의 데이터를 분산시킬 수 있다는 특징을 갖고 있다.

    stream과 소비자 그룹은 독립적으로 동작할 수 있다. 즉 Email이라는 stream메시지를 읽어가기 위한 소비자 그룹은 다수 존재할 수 있으며, 각각 독립적으로
    동작한다. 소비자 그룹 1의 소비자가 a라는 메시지를 읽었다면 같은 그룹에서는 그 메시지를 다시 읽을 수 없지만, 소비자 그룹 2 혹은 일반적인 다른 소비자에서는
    해당 메시지를 읽을 수 있다. 하나의 소비자 그룹에서 여러 개의 stream을 리스닝하는 것도 가능하다.

    > XGROUP CREATE Email bigroup 0
    > XGROUP CREATE push bigroup 0

    > XREADGROUP GROUP BIGroup BI1 COUNT 2 STREAMS Email Push > >

    XGROUP 커맨드를 이용해 각 stream에 BIGroup이라는 이름을 가진 소비자 그룹을 먼저 생성한 뒤, XREADGROUP 커맨드를 이용해서 데이터를 읽으면
    BIGroup은 Email과 push 2개의 stream을 리스닝할 수 있게 된다.

    Email과 Push의 두 가지 stream에는 각각 실시간 데이터가 쌓이게 된다. EmailServiceGroup 소비자 그룹의 각 이메일 서버들은 Email 서비스의 메시지를
    읽어가며, NotificationServiceGroup 소비자 그룹에서는 Email Push 2개 stream에서 모두 데이터를 읽어가고 있다. BI 서비스는 소비자 그룹을
    이용하지 않고 하나의 소비자가 데이터를 읽어가는 모습을 나타내며, 이때에 각 stream데이터는 정렬돼 전달된다.

    소비자 그룹에 전달되는 모든 데이터는 시간 순으로 정렬돼 있으며, stream에 쌓인 메시지는 해당 데이터가 필요한 여러 서비스로 분산돼 읽힐 수 있다.

    ACK와 보류 리스트
    여러 서비스가 메시지 브로커를 이용해 데이터를 처리할 때, 예상치 못한 장애로 인해 시스템이 종료됐을 경우 이를 인지하고 재처리할 수 있는 기능이 필요하다.
    메시지 브로커는 각 소비자에게 어떤 메시지까지 전달됐고, 전달된 메시지의 처리 유무를 인지하고 있어야 한다.

    레디스 stream에서는 소비자 그룹에 속한 소비자가 메시지를 읽어가면 각 소비자별로 읽어간 메시지에 대한 리스트를 새로 생성하며, 마지막으로 읽어간 데이터의
    ID로 last_delivered_id 값을 업데이트 한다. last_delivered_id 값은 해당 소비자 그룹에 마지막으로 전달한 ID가 무엇인지를 파악해, 동일한
    메시지를 중복으로 전달하지 않기 위해 사용된다.

    레디스 stream은 소비자별로 보류 리스트를 만들고, 어떤 소비자가 어떤 데이터를 읽어갔는지 인지하고 있다.
    만약 이메일 서비스 2가 stream에게 데이터가 처리됐다는 뜻의 ACK를 보내면 레디스 stream은 이메일 서비스 2의 보류 리스트에서 ACK를 받은 메시지를 삭제한다.

    즉 보류 리스트를 이용해 소비자가 처리한 데이터를 파악할 수 있다. 예를 들어 이메일 서비스에 문제가 발생해 서비스를 재부팅해야 하는 상황에서, stream의
    보류 리스트에 데이터가 남아 있는 경우 해당 데이터를 먼저 불러와 처리하는 작업을 선행적으로 수행한다면 예상치 못한 서비스 중단 상황에서도 모든 메시지를
    놓치지 않고 처리 할 수 있게 된다.

    만약 이메일 서버 1에 장애가 발생해 해당 서버를 당분간 사용할 수 없는 상태가 됐을 때, 1번 서버가 작업중이던 메시지를 다른 서버에서 처리해야 할 수 있다.
    이를 위해서는 1번 서버의 보류 리스트에 남아있는 메시지가 있는지 확인하는 과정을 거치면 된다. 따라서 XREADGROUP를 이용해 소비자 그룹 형태로 데이터를
    읽었을 때, 데이터 처리가 완료된 후에 애플리케이션에서 XACK를 주기적으로 전송하는 작업이 필요하다.

    ** 현재 소비자 그룹에서 보류 중인 리스트가 있는지 확인하는 커맨드
        > XPENDING <key> <groupname> [<start-id> <end-id> <count> [<consumer-name>]]

        > XPENDING Email EmailServiceGroup
        1) (integer) 9
        2) "1659114481311-0"
        3) "1659114485678-0"
        4) 1) 1) "es1"
              2) "1"
           2) 1) "es2"
              2) "1"
           3) 1) "es3"
              2) "7"

        반환되는 첫 번째 값은 현재 소비자 그룹에서 ACK를 받지 못해 보류 중인 메시지의 개수이며, 두번째 세번째 값은 각각 보류 중인 메시지 ID의
        최솟값, 최댓값이다. 그 뒤로는 각 소비자별로 보류 중인 리스트가 몇 개 있는지 알려준다.

        XACK를 이용해 다음과 같이 데이터가 처리됐음을 알려줄 수 있다.
        > XACK Email EmailServiceGroup 1659114481311-0
        (integer) 1

        카프카도 레디스 stream과 비슷하게 파티션별 오프셋을 관리한다. 카프카는 내부적으로 __consumer_offsets라는 토픽에 데이터를 기록하는데,
        소비자가 지정된 토픽의 특정 파티션의 메시지를 읽으면 소비자 그룹, 토픽, 파티션 내용이 통합돼 저장된다. 소비자 그룹은 __consumer_offsets
        토픽에 기록된 정보를 이용해 내부 소지자가 어디까지 읽었는지 추적할 수 있다. 카프카에서 오프셋은 소비자가 마지막으로 읽은 위치가 아니라 다음으로
        읽어야 할 위치를 기록한다.

        1.소비자 그룹이 시작할 때, Kafka는 해당 소비자 그룹의 마지막 오프셋 위치를 확인합니다.
        2.소비자는 그 오프셋 위치에서 메시지 읽기를 시작하여, 새로운 메시지들을 처리합니다.
        3.메시지를 처리한 후, 소비자는 읽은 마지막 메시지 다음의 오프셋 위치로 오프셋을 업데이트합니다.

    ** 레디스 stream에서의 at most once vs at least once vs exactly once
        메시징 시스템에서는 다음과 같은 세 가지의 메시지 보증 전략을 갖추고 있다.

        - at most once : 메시지를 최소 한 번 보내는 것을 믜미한다. 소비자는 메시지를 받자마자 실제 처리하기 전에 먼저 ACK를 보낸다.
            이로 인해 속도는 향상되지만 ACK를 보낸 뒤 소비자에 문제가 생겨 서비스가 다운 됐을때에는 이미 ACK를 보냈지만 실제 처리하지못한
            데이터는 잃을 수 있다. 메시지가 일부 손실되더라도 빠른 응답이 필요한 경우 선택하는 전략이다.

        - at least once : 소비자가 받은 메시지를 모두 처리한 뒤 ACK를 보낸다.
            ACK 전송이 지연돼, 실제로 메시지가 처리됐지만 ACK를 전송하기 전에 소비자가 종료되는 상황이 발생할 수도 있다.
            이럴 경우 보류 리스트에 처리된 메시지도 남아있기 때문에 이미 처리한 이미지를 한 번 더 처리하게 되는 상황이 발생할 수도 있다.
            이메일 서버 1에서 129-0과 130-1을 받은 뒤 129-0 메시지는 처리했고, 130-1은 처리하지 못해서 ACK를 보내지 못하고
            서비스가 재시작됐다면, 보류 리스트에 남아있는 메시지를 다시 전부 읽어가기 때문에 이 경우 130-1 메시지는 두 번 처리하게 된다.
            만약 멱등함이 보장되는 서비스라면 상관없지만, 그렇지 않을 경우 문제가 될 수지가 있다.

        - exactly once: 모든 메시지가 무조건 한 번씩 전송되는 것을 보장한다는 의미로, 이런 방식으로 메시지를 전송하려면 추가적인 기능이
            필요할 수 있다. 만약 레디스 stream을 이용하면서 exactly once하게 메시지를 전송하고 싶다면 레디스의 set등의 추가 자료 구조를
            이용해 이미 처리된 메시지인지 아닌지를 확인하는 과정이 필요할 수 있다.

    ** 메시지의 재할당
        레디스는 소비자에게 장애가 날 경우를 대비해 소비자별 보류 리스트를 유지한다고 설명했다. 만약 소비자 서버에 장애가 발생해 복구되지 않았다면
        해당 소비자가 처리하던 보류 중인 메시지들은 다른 소비자가 대신 처리해야 한다.
        XCLAIM 커맨드를 이용하면 메시지의 소유권을 다른 소비자에게 할당할 수 있다.

        > XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2> ... <ID-N>

        XCLAIM 커맨드를 사용할 때에는 최소 대기 시간을 지정해야 한다. 이는 메시지가 보류 상태로 머무른 시간이 최소 대기 시간을 초과한 경우에만
        소유권을 변경할 수 있도록 같은 메시지가 2개의 다른 소비자에게 중복으로 할당되는 것을 방지할 수 있다.

        EmailService3라는 소비자에 문제가 생겨, 이 소비자가 처리하던 메시지를 다른 소비자인  EmailService1, 2가 가져가기 위해
        XCLAIM 커맨드를 실행하는 상황을 가정하자

        EmailService 1: XCLAIM Email EmailServiceGroup EmailService 3 3600000
        1626569498055-0
        EmailService 2: XCLAIM Email EmailServiceGroup EmailService 3 3600000
        1626569498055-0

        2개의 소비자가 모두 보류 중인 메시지에 XCLAIM 커맨드를 실행했지만, 위의 예제처럼 EmailService1의 커맨드가 먼저 실행되면
        메시지의 보류 시간이 즉시 0으로 재설정된다. EmailService2에서 실행한 XCLAIM 커맨드에서의 최소 대기 시간보다 메시지의 보류 시간이 짧기
        때문에 이 커맨드는 무시되며, 이를 통해 중복 메시지 할당을 방지할 수 있다.

    ** 메시지의 자동 재할당
        소비자가 직접 보류했던 메시지 중 하나를 자동으로 가져와서 처리할 수 있도록 하는 XAUTOCLAIM 커맨드는 할당 대기 중인 다음 메시지의 ID를
        반환하는 방식으로 동작하기 때문에 반복적 호출이 가능하다.

        XAUTOCLAIM <key> <group> <consumer> <min-idle-time> <start> [COUNT count] [JUSTID]

        다음과 같이 지정한 소비자 그룹에서 최소 대기 시간을 만족하는 보류 중인 메시지가 있다면 지정한 소비자에 소유권을 재할당하는 방식으로 동작한다.
        XCLAIM 커맨드에서 처럼 직접 재할당할 메시지를 입력해주지 않아도 되기 때문에 간단하게 메시지의 재할당이 가능하다.

        > XAUTOCLAIM Email EmailServiceGroup es1 360000 0-0 count 1
        1) "1659170655277-0"
        2) 1) 1) "1659114966798-0"
              2) 1) "subject"
                 2) "second"
                 3) "body"
                 4) "hihi"

        위의 예제에서와 같이 XAUTOCLAIM 커맨드를 실행하면 첫 번째 반환값으로는 다음으로 대기 중인 보류 메시지의 ID가 반환된다.
        더 이상 대기 중인 보류 메시지가 없을 경우, 0-0이 반환된다. 두 번째 반환값은 소유권이 이전된 메시지의 정보를 제공하며, 이 정보에는
        메시지의 ID와 해당 메시지의 내부 필드-값 쌍이 순서대로 포함돼 있다.
        이 메시지의 소유권은 es1에게 할당됐음을 알 수 있다.

    ** 메시지의 수동 재할당
        stream 내의 각 메시지는 counter라는 값을 각각 가지고 있다. XREADGROUP을 이용해 소비자에게 할당하거나 XCLAIM 커맨드를 이용해
        재할당할 경우 1씩 증가하게 된다. 메시지가 처리되지 못하고 보류될 경우, 위와 같은 프로세스에 의해 새로운 소비자에게 다시 할당돼 처리
        되고자 한다.

        하지만 만약 메시지에 문제가 있어 처리되지 못할 경우 메시지는 여러 소비자에게 할당되기를 반복하면서 counter 값이 계속 증가하게 된다.
        따라서 counter가 특정 값에 도달하면 이 메시지를 특수한 다른 stream으로 보내, 관리자가 추후에 처리할 수 있도록 하는 것이 현명할 수 있다.
        보통 이런 메시지를 dead letter라 부른다.

    ** stream 상태 확인
        일반적인 메시징 시스템이 그렇든 어떤 소비자가 활성화됐는지, 보류된 메시지는 어떤 건지, 어떤 소비자 그룹이 메시지를 처리하고 있는지 등의
        상태를 확인하는 커맨드가 없다면 stream을 관리하기 까다로울 것이다.

        XINFO 커맨드를 이용해 stream의 여러 상태를 확인할 수 있으며, 이때 사용할 수 있는 기능은 help 커맨드로 확인할 수 있다.

        XINFO HELP

        XINFO consumers <stream key> <소비자 그룹 이름> 커맨드를 이용해 특정 소비자가
        그룹에 속한 소비자의 정보를 알 수 있다.

        > XINFO consumers email emailservicegroup
        1) 1) "name"
           2) "es1"
           3) "pending"
           4) "(integer) 1"
           5) "idle"
           6) "(integer) 650129"
        2) 1) "name"
           2) "es2"
           3) "pending"
           4) "(integer) 0"
           5) "idle"
           6) "(integer) 437738623"

        > XINFO GROUPS <stream key> 커맨드를 이용해 stream에 속한 전체 소비자 그룹 list를 볼 수 있다.

        > XINFO GROUPS email
        1) 1) "name"
           2) "bigroup"
           3) "consumers"
           4) "(integer) 1"
           5) "pending"
           6) "(integer) 6"
           7) "last-delivered-id"
           8) "1653455675-0"
           9) "entries-read"
           10) "(integer)6"
           11) "lag"
           12) "(integer)4"
        2) ...

        > XINFO STREAM <stream key>를 이용하면 stream 자체의 정보를 알 수 있다.
        stream이 내부적으로 어떻게 인코딩되고 있는지 그리고 첫 번째와 마지막 메시지의 ID를 표시한다.