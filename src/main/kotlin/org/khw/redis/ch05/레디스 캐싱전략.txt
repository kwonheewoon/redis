* 캐싱정략
    레디스를 캐시로 사용할 때 레디스를 어떻게 배치할 것인지에 따라 서비스의 성능에 큰 영향을 끼칠 수 있다. 캐싱정략은 캐싱되는 데이터의 유형과
    데이터에 대한 액세스 패턴에 따라 다르기 때문에 서비스에 맞는 적절한 캐싱 전략을 선택하는 것이 중요하다.

    * 읽기 전략 - look aside
        애플리케이션에서 데이터를 읽어갈 때 주로 사용하는 look aside 전략은 레디스를 캐시로 사용할때 가장 일반적인 방법
        찾고자 하는 데이터가 캐시에 있는지를 확인한 뒤, 캐시에 데이터가 있으면 캐시에서 데이터를 읽어온다. 이를 캐시 히트라고 한다.
        찾고자 하는 데이터가 없을 때에는 캐시 미스가 발생, 캐시 미스가 발생하면 레디스로부터 데이터가 없다는 응답을 반은 뒤
        애플리케이션은 직접 데이터베이스에 접근해 찾고자 하는 데이터를 가져온다. 그 뒤 애플리케이션은 이를 다시 캐시에 저장하는 과정을 거친다.

        장점 : 레디스에 문제가 생겨 접근을 할 수 없는 상황이 발생하더라도 바로 서비스 장애로 이어지지 않고 데이터베이스에서 데이터를 가지고 올 수 있다
        단점 : 기존에 애플리케이션에서 레디스를 통해 데이터를 가져오는 연결이 매우 많았다면 모든 커넥션이 한꺼번에 원본 데이터베이스로 몰려 많은 부하를 발생시키고
            이로 인해 원본 데이터베이스의 응답이 느려지거나 리소스를 많이 차지하는 등의 이슈가 발생해 애플리케이션의 성능에 영향을 미칠수 있다.

        찾고자 하는 데이터가 레디스에 없을때 레디스에 데이터를 적재하기 때문에 lazy loading 구조라고 부른다.

        만약 기존에 사용중인 서비스에 처음 레디스를 투입하거나 데이터베이스에만 새로운 데이터를 저장한다면 애플리케이션은 데이터를 찾기 위해
        레디스에 매번 먼저 접근할 것이고 그때마다 캐시 미스가 일어나 데이터베이스와 레디스에 재접근하는 과정을 통해 지연이 초래돼 성능에 영향을 미칠수 있다
        이럴 때에는 미리 데이터베이스에서 캐시로 데이터를 밀어넣어주는 작업을 하기도 하는데, 이를 캐시 워밍(cache warming)이라고 한다


    * 캐시 불일치(cache inconsistency)
        캐시는 데이터베이스에 저장돼 있는 데이터를 단순히 복사해 온 값이다.
        따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적이다. 만약 데이터가 변경될 때 원본 데이터베이스에만 업데이트돼 캐시에는 변경된 값이 반영되지 않는다면
        데이터간 불일치가 일어난다.

    * 쓰기 전략 - write through
        write through 방식은 데이터베이스에 업데이트할 때마다 매번 캐시에도 데이터를 함께 업데이트시키는 방식으로, 캐시는 항상 최신 데이터를 가지고 있을 수 있다는
        장점이 있지만, 데이터는 매번 2개의 저장소에 저장돼야 하기 때문에 데이터를 쓸 때마다 시간이 많이 소요될 수 있다는 단점이 있다.
         ㄴ 캐시의 목적은 데이터의 재활용인데 재활용 가능성이 없을수도 있기 때문에 이 전략에는 만료시간 사용 할 것을 권장

    * 쓰기 전략 - cache invalidation
        cache invalidation은 데이터베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략이다. 저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를
        저장하는 것보다 훨씬 리소스를 적게 사용하기 때문에 앞선 write through의 단점을 보완한 방법이라고 볼 수 있다.

    * 쓰기 전략 - write behind
        쓰기가 빈번하다면 write behind 방식을 고려해볼 수 있다. 데이터베이스에 대량의 쓰기 작업이 발생하면 이는 많은 디스크 I/O를 유발해, 성능 저하가 발생할 수 있다.
        따라서 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트한 뒤, 이후에는 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트하는 것이다.

        저장되는 데이터가 실시간으로 정확한 데이터가 아니어도 되는 경우 이 방법이 유용할수 있다. 예를 들어 유튜브와 같은 스트리밍 사이트의 동영상 좋아요 수는 매번
        실시간 집계가 필요하진 않다. 누군가가 업데이트를 할 때마다 그 데이터가 바로 관계형 데이터베이스에 업데이트된다면 이는 심각한 성능 저하를 가져올 수 있다.
        좋아요를 누른 데이터를 우선 레디스에 저장해둔 다음 5분 간격으로 이를 집계해 데이터베이스에 저장하는 과정을 거친다면 데이터베이스의 성능을 향상시켜 애플리케이션의
        성능도 향상시킬 수 있다.