* 레디스에서 데이터를 영구 저장하기
    레디스에서 모든 데이터는 메모리에서 관리된다. 따라서 레디스 인스턴스 혹은 레디스가 실행되는 서버의 장애로 인해 레디스 인스턴스가 재시작될 경우 메모리에
    상주해 있던 레디스의 모든 데이터는 손실될 가능성이 있다.

    레디스를 복제 구조로 사용할 경우 데이터가 실시간으로 복제본에 전달되고 있으니 따로 데이터를 백업할 필요를 느끼지 못할 수도 있다. 하지만 백업과 복제는
    목적부터 다르다는 점에 유의하자. 복제는 가용성을 위한 것이며, 백업은 장애 상황에서 데이터의 복구를 위해 필요하다. 만약 개발자의 실수 혹은
    프로그램상의 버그로 인해 마스터 노드에서 의도하지 않은 데이터를 삭제하는 커맨드가 실행되면 이는 바로 복제본에 전달된다. 따라서 복제 구조만으로는
    데이터를 안전하게 유지할 수 없다.

    레디스를 캐시가 아닌 영구 저장소와 같은 용도로 사용한다면 디스크에 데이터를 주기적으로 백업하는 것이 안전하다. 데이터를 안전하게 저장하기 위해 레디스에서는
    RDB와 AOF 두 가지의 백업 방식을 지원한다.

    - AOF(Append Only File) : 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록. 복원 시에는 파일을 다시 읽어가며 데이터 세트 재구성
    - RDB(Redis DataBase) : 일정 시점에 메모리에 저장된 데이터 전체를 저장(snapshot 방식)

    > SET key1 a
    OK

    > SET key1 apple
    OK

    > SET key2 b
    OK

    > DEL key2
    (integer) 1

    위 예제에서는 key1이라는 키에 a라는 값을 저장한 뒤 key1에 다시 apple을 저장한다. a라는 값은 없어지고 apple로 덮어 씌워진다.
    key2에는 b를 저장한 뒤 del 커맨드를 이용해 키를 삭제했다.

    AOF 방식
        set key1 a
        set key1 apple
        set key2 b
        del key2

    RDB 방식
        key1 -> apple

    실제 RDB 파일은 바이너리 형태로 저장돼 우리가 읽고 해석할 수 없는 형태이며 AOF 파일은 레디스 프로토콜(RESP) 형태로 저장된다.

    AOP 파일에는 레디스에서 실행된 모든 쓰기 작업이 기록된다. key1의 데이터가 다른 값으로 변경된 내역, key2가 생성됐다가 삭제된 내역 모두
    AOF 파일에 기록된다. 따라서 AOF 파일을 처음부터 끝까지 따라가면 원본 데이터에 도달할 수 있게 된다.

    RDB 파일에는 저장되는 시점의 메모리 데이터가 그대로 저장된다. 사진을 찍듯 메모리의 데이터를 그대로 내려쓰기 때문에 스냅샷 방식이라고 한다.
    특정 커맨드를 모두 실행한 뒤 RDB 파일을 생성한다면 RDB 파일에는 실제로 메모리에 저장된 값인 key1의 값이 apple이라는 데이터만 남아 있게 된다.

    각 방식은 모두 장단점을 갖고 있다. RDB 파일의 경우, 시점 단위로 여러 백업본을 저장할 수 있고 AOF 파일보다 복원이 빠르다는 장점이 있지만
    특정 시점으로의 복구는 불가능하다. AOF는 RDB 파일보다 크기가 크고 주기적으로 압축해 재작성해야 하지만, 원하는 시점으로 복구할 수 있다는 장점이 있다.

    하나의 인스턴스에서 RDB와 AOF 옵션을 동시에 사용하는 것도 가능하며, 일반적인 RDB 만큼의 데이터 안정성을 원하는 경우 두 가지 백업 방식을
    동시에 사용하기를 권장한다. 데이터를 복원할 때 AOF 파일이 존재한다면 레디스는 더 안전하다고 판단되는 AOF 파일을 복원 시 사용하지만 데이터의 안정성을
    위해서는 주기적인 RDB 스냅샷을 갖는 것이 좋기 때문이다

    레디스에서 데이터를 복원할 수 있는 시점은 서버가 재시작될 때뿐이며, 레디스 인스턴스 실행 도중에 데이터 파일을 읽어올 수 있는 방법은 없다.

    레디스 서버는 재시작될때 AOF 파일이나 RDB 파일이 존재하는지 확인한 뒤, 파일이 있을 때에는 파일을 로드한다. 레디스는 RDB 파일보다 AOF 파일이 더
    내구성이 보장된다고 판단하기 때문에 2개의 파일이 모두 존재할 때에는 AOF의 데이터를 로드한다.

* RDB 방식의 데이터 백업
    RDB 파일은 레디스에서 데이터를 백업하기 위한 가장 단순한 방법이다. 원하는 시점에 메모리 자체를 스냅샷 찍듯 저장할 수 있기 때문에 백업에 적합한 파일
    형태라고 볼 수 있다. 예를 들어 한 시간에 한 번씩 RDB 파일을 생성할 수 있으며, 장애 발생시 원하는 시점으로 데이터를 복원할 수 있다.
    RDB 파일이 저장될 때마다 원격 저장소로 파일을 옮겨 2차 백업을 수행한다면 데이터 센터 장애 등 더 큰 장애에도 대처할 수 있다.

    하지만 장애가 발생했을때 손실 가능성을 최소화해야 하는 서비스에는 RDB 파일을 이용한 백업만 사용하는 것은 적절하지 않다. 사용자가 지정한 시간 단위로
    파일이 저장되기 때문에 저장 시점부터 장애가 발생한 직전까지의 데이터는 손실될 수 있다는 것을 알아둬야 한다.

    RDB 파일을 생성할 수 있는 방법은 크게 세 가지다. 설정파일에서 특정 조건에 파일이 자동으로 저장되도록 지정할 수 있으며, 사용자가 원하는 시점에
    커맨드를 이용해 수동으로 파일을 생성할 수도 있다. 복지 기능을 사용한다면 레디스는 자동으로 RDB 파일을 생성한다.

    ** 특정 조건에 자동으로 RDB 파일 생성
        save <기간(초)> <기간 내 변경된 키의 개수>
        dbfilename <RDB 파일 이름>
        dir <RDB 파일이 저장될 경로>

        레디스의 설정 파일에서 save 옵션을 사용해 원하는 조건에 RDB 파일을 저장하도록 설정할 수 있다. 일정한 기간(초) 동안 변경된 키의 개수가 조건에 맞을 때
        레디스 서버는 자동으로 RDB 파일을 저장한다. RDB 파일은 dbfilename 옵션에 지정된 이름으로 생성되며, 기본값은 dump.rdb이다.
        파일은 dir에 지정한 경로에 저장된다.

        save 900 1
        save 300 10
        save 60 10000

        redis.conf에 위와 같은 조건으로 save 옵션을 설정한다면 인스턴스는 다음과 같은 상황에서 RDB 파일을 생성한다.
            - 900초 동안 1개 이상의 키가 변경된 경우
            - 300초 동안 10개 이상의 키가 변경된 경우
            - 60초 동안 10,000개 이상의 키가 변경된 경우

        만약 RDB 파일을 저장하고 싶지 않다면 save "" 와 같이 빈 문자열로 설정해서 옵션을 비활성화할 수 있다.
        이미 레디스 인스턴스가 실행 중인 상태에서 RDB 저장을 비활성화 하고 싶다면 CONFIG SET 커맨드를 이용해 save 파라미터를 ""로 초기화 시키면 된다.

        # 현재 적용된 save 옵션확인
        > CONFIG GET save
        1) "save"
        2) "900 1 300 10 60 10000" (redis 디폴트 값)

        # save 옵션 초기화
        > CONFIG SET save ""
        OK

        # redis.conf 파일 재작성
        > CONFIG REWRITE
        OK

        *** CONFIG REWRITE
            레디스 인스턴스가 실행 중인 상태에서 설정 파일을 변경하는 것은 실행 중인 레디스 인스턴스에는 반영되지 않는다.
            실행 중인 레디스 인스턴스에서 파라미터를 수정할 때에는 redis-cli에서 직접 CONFIG SET 커맨드로 설정을 변경한 뒤
            CONFIG REWRITE 커맨드를 이용해 설정 파일을 재작성하는 과정을 거쳐야 한다. 설정 파일을 재작성하지 않은 상태에서
            레디스 인스턴스가 재시작된다면 레디스 인스턴스는 기존 설정 파일에 작성된 옵션, 즉 변경되지 않은 옵션 값으로 설정된다.

    ** 수동으로 RDB 파일 생성
        SAVE, BGSAVE 커맨드를 이용하면 원하는 시점에 직접 RDB 파일을 생성할 수 있다. 두 커맨드 모두 실행 시점의 메모리 스냅샷을 생성하는 커맨드이지만
        동작하는 방식에 차이가 있다. SAVE는 동기 방식으로 파일을 저장한다. SAVE 커맨드를 실행하면 파일생성이 완료될 때까지 다른 모든 클라이언트의 명령을
        차단한다. 메모리 전체를 스캔해 파일이 저장되기까지 1분이 걸린다면 그 1분 동안 레디스 인스턴스에 연결된 다른 클라이언트는 아무런 명령도
        수행할 수 없는 상황을 맞게 된다. 따라서 일반적인 운영환경에서는 SAVE 커맨드를 되도록 사용하지 않는 것이 좋다.

        BGSAVE는 fork를 호출해 자식 프로세스를 생성하며 생성된 자식 프로세스가 백그라운드에서 RDB 파일을 생성한 뒤 종료된다.
        레디스를 이용하는 다른 클라이언트는 원래대로 부모 프로세스를 이용해서 처리되기 때문에 파일 저장에는 영향을 받지 않는다.
        만약 이미 백그라운드로 데이터가 저장되고 있을 때 이 커매드를 수행하면 에러를 반환한다. 이런 상황에서는 BGSAVE와 함께
        SCHEDULE 옵션을 사용할 수 있는데, 이미 파일이 백그라운드에서 자장 중일 때 이 커맨드를 입력받은 레디스는 일단 OK를 반환한 뒤,
        기존에 진행 중이던 백업이 완료 됐을 때 다시 BGSAVE를 실행한다.

        RDB 파일이 정상적으로 저장됐는지는 LASTSAVE 커맨드로 확인할 수 있으며, 마지막으로 RDB 파일이 저장된 시점을 유닉스 타임스탬프로 반환한다.

    ** 복제를 사용할 경우 자동으로 RDB 파일 생성
        replica에서 REPLICAOF 커맨드를 이용해 복제를 요청하면 마스터 노드에서는 RDB 파일을 새소 생성해 복제본에 전달한다.
        혹은 이미 족제 연결이 돼 있는 상태에서 네트워크 등의 이슈로 인해 일정 시간 이상 복제가 끊어졌다가 복구된 경우 복제 재연결이 발생하며,
        이럴 경우에는 마스터 노드는 복제본으로 RDB 파일을 전송한다. 따라서 복제 연결을 처음 시작했을 때뿐만 아니라 이미 족제 연결이 돼 있는 상태에서도
        상황에 따라 마스터에서는 언제든지 RDB 파일을 재생성할 수 있다.


* AOF 방식의 데이터 백업
    AOF는 레디스 인스턴스에서 수행된 모든 쓰기 작업의 로그를 차례로 기록한다. 실수로 FLUSHALL 커맨드로 데이터를 모두 날려버렸다 해도, AOF 파일을
    직접 열어 FLUSHALL 커맨드만 삭제한 뒤 레디스를 재시작 시킨다면 커맨드를 실행하기 직전까지로 데이터를 바로 복구할 수 있다.

    설정 파일에서 appendonly 옵션을 yes로 지정하면 AOF 파일에 주기적으로 데이터가 저장된다. AOF 파일은 appenddirname에서 지정한 경로와
    appendfilename 옵션에 설정한 이름으로 생성된다.

    appendonly yes
    appendfilename "appendonly.aof"
    appenddirname "appendonlydir"

    appendfilename 옵션을 이용해 AOF 파일명을 변경하지 않는다면 기본적으로 AOF 파일은 appendonly.aof라는 이름으로 저장된다.
    버전 7.0 이상부터 AOF 파일은 여러개로 저장되며, 이는 appenddirname 옵션에서 지정된 디렉터리 하위에 저장된다.
    appenddirname 옵션에는 경로가 아닌 디렉터리 이름만 지정할 수 있으며, dir 옵션 하위에 생성된다.

    > SET key1 apple
    OK

    > SET key1 beer
    OK

    > DEL key1
    (integer) 1

    > DEL non_existing_key
    (integer) 0

    위 예제에서 첫 번째부터 세 번째까지의 커맨드는 레디스 서버의 메모리에 영향을 끼치는 작업이고, 네 번째 커맨드는 존재하지 않는 키를 삭제하는 작업이기
    때문에 메모리가 수정되는 작업은 아니다. AOF 파일에는 메모리상의 데이터가 변경되는 커맨드만 기록되기 때문에 마지막의 DEL non_existing_key 작업은 기록되지 않는다.

    AOF에서 모든 커맨드의 실행 내역은 다음과 같이 레디스 프로토콜(RESP) 형식으로 저장된다.

    *3
    $3
    set
    $4
    key1
    $5
    apple
    *3
    $3
    set
    $4
    key1
    beer
    *2
    $3
    del
    $4
    key1

    하지만 항상 AOF 파일의 사용자가 실행한 커맨드를 그대로 저장하는 것은 아니다 예를 들어 list에서 블로킹 기능을 지원하는 BRPOP 커맨드는
    AOF 파일에 저장될 때에는 RPOP로 기록된다. AOF 파일에서 블로킹 기능을 굳이 명시해줄 필요는 없기 때문이다.

    기존 string 값에 사용자가 입력한 부동소수점 값을 더해주는 INCRBYFLOAT 커맨드도 AOF 파일에는 그대로 기록되지 않는다.

    레디스가 실행되는 아키텍처에 따라 부동소수점을 처리하는 방식이 다를 수 있기 때문에 AOF 파일에는 증분 후의 값을 직접 SET 하는 커맨드로 변경돼 저장된다.

    AOF는 Append-Only File이라는 이름 뜻 그대로 실행되는 커맨드가 파일의 뒤쪽에 계속 추가되는 방식으로 동작한다. 따라서 인스턴스가 실행되는 시간에
    비례해서 AOF 파일의 크기는 계속 증가하게 되다. INCR 커맨드를 사용해 counter 키를 100번 증가시킨다면 실제 레디스의 메모리에서 counter라는 키는
    100이 증가된 값을 저장하고 있지만, AOF 파일에는 키를 증가시킨 100번의 실행 내역이 그대로 남아 있게 된다

    ** AOF 파일을 재구성하는 방법
        따라서 AOF 파일을 이용한 백업 기능을 안정적으로 사용하려면 점점 커지는 파일을 주기적으로 압축시키는 재구성(rewrite) 작업이 필요하다.
        RDB에서와 마찬가지로 특정 조건에 자동으로 재구성되도록 설정할 수도 있으며, 사용자가 원하는 시점에 커맨드를 이용해 재구성시킬 수 있다.

        이때 압축, 즉 재구성은 기존 디스크에 저장됐던 AOF 파일을 사용하는 것이 아니라 레디스 메모리에 있는 데이터를 읽어와서 새로운 파일로 저장하는 형태로
        동작한다.
        설정 파일에서 기본 옵션인 aof-use-rdb-preamble yes를 no로 변경하지 않는다면 이 데이터는 RDB 파일 형태로 저장한다.
        RDB 파일을 저장할 때와 마찬가지로 AOF파일을 재구성할 때에도 fork를 이용해 자식 프로세스를 생성하며, 이 자식 프로세스가 AOF 파일을 재구성해 저장한다.

        *** 버전 7 이전에서의 aof 파일
            RDB file(binary) -- 고정영역
            AOF tail(RESP 프로토콜) 증분영역

        버전 7 이전까지 AOF는 하나의 파일로 관리됐다 AOF 파일의 앞부분은 메모리의 데이터를 읽어와 바이너리 형태로 저장한 RDB 파일이 위치한다.
        이후 레디스의 메모리를 변경한 커맨드 로그들은 RESP 형태로 RDB 파일의 뒤에 쌓이는 형태로 증가한다.


